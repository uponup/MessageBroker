//
//  RatchetMessageKeys.swift
//  SignalProtocolSwift
//
//  Created by User on 12.10.17.
//  Copyright Â© 2017 User. All rights reserved.
//

import Foundation

/**
 The keys needed to encrypt/decrypt a message
 */
struct RatchetMessageKeys {

    /// The length of cipher keys in bytes
    static let cipherKeyLength = 32

    /// The length of the mac key in bytes
    static let macKeyLength = 32

    /// The length of the initialization vector in bytes
    static let ivLength = 16

    /// The length of cipher key, mac key, and iv
    static let derivedMessageSecretsSize = cipherKeyLength + macKeyLength + ivLength

    /// The cipher key to encrypt/decrypt a message
    var cipherKey: Data

    /// The mac key of a message
    var macKey: Data

    /// The initialization vector
    var iv: Data

    /// The counter of the message
    var counter: UInt32

    /**
     Create the message keys from the components
     - parameter cipher: The cipher key
     - parameter mac: The mac key
     - parameter iv: The initialization vector
     - counter: The counter of the message
     - throws: `SignalError` of type `invalidLength`, if the key lengths are invalid
    */
    init(cipher: Data, mac: Data, iv: Data, counter: UInt32) throws {
        guard cipher.count == RatchetMessageKeys.cipherKeyLength else {
            throw SignalError(.invalidLength, "Invalid cipher key length \(cipher.count)")
        }
        guard mac.count == RatchetMessageKeys.macKeyLength else {
            throw SignalError(.invalidLength, "Invalid mac key length \(mac.count)")
        }
        guard iv.count == RatchetMessageKeys.ivLength else {
            throw SignalError(.invalidLength, "Invalid iv length \(iv.count)")
        }
        self.cipherKey = cipher
        self.macKey = mac
        self.iv = iv
        self.counter = counter
    }

    /**
     Create the message keys from generated bytes.
     - parameter bytes: The bytes to create the message keys from.
     - throws: `SignalError` of type `invalidLength`, if the number of bytes is invalid
    */
    init(material: Data) throws {
        guard material.count == RatchetMessageKeys.derivedMessageSecretsSize + MemoryLayout<UInt32>.size else {
            throw SignalError(.invalidLength, "Missing bytes in RatchetMessageKeys data")
        }
        self.cipherKey = material[0..<RatchetMessageKeys.cipherKeyLength]
        let length2 = RatchetMessageKeys.cipherKeyLength + RatchetMessageKeys.macKeyLength
        self.macKey = material[RatchetMessageKeys.cipherKeyLength..<length2]
        self.iv = material[length2..<RatchetMessageKeys.derivedMessageSecretsSize]
        self.counter = material
            .advanced(by: RatchetMessageKeys.derivedMessageSecretsSize)
            .withUnsafeBytes { ptr in
            ptr.baseAddress!.assumingMemoryBound(to: UInt32.self).pointee
        }
    }
}

// MARK: Protocol Buffers

extension RatchetMessageKeys: ProtocolBufferEquivalent {

    /// The message keys converted to a ProtoBuf object
    var protoObject: Signal_Session.Chain.MessageKey {
        return Signal_Session.Chain.MessageKey.with {
            $0.index = self.counter
            $0.cipherKey = self.cipherKey
            $0.iv = self.iv
            $0.macKey = self.macKey
        }
    }

    /**
     Create message keys from a ProtoBuf object.
     - parameter protoObject: The ProtoBuf object
     - throws: `SignalError` of type `invalidProtoBuf`, if data is missing or corrupt
     */
    init(from protoObject: Signal_Session.Chain.MessageKey) throws {
        guard protoObject.hasIndex, protoObject.hasCipherKey, protoObject.hasIv, protoObject.hasMacKey else {
            throw SignalError(.invalidProtoBuf, "Missing data in RatchetMessageKeys protobuf object")
        }
        self.counter = protoObject.index
        self.cipherKey = protoObject.cipherKey
        self.iv = protoObject.iv
        self.macKey = protoObject.macKey
    }
}

// MARK: Protocol Equatable

extension RatchetMessageKeys: Equatable {
    /**
     Compare two message keys for equality.
     - parameter lhs: The first message
     - parameter rhs: The second message
     - returns: `True`, if the message keys are equal
     */
    static func ==(lhs: RatchetMessageKeys, rhs: RatchetMessageKeys) -> Bool {
        return lhs.counter == rhs.counter &&
            lhs.cipherKey == rhs.cipherKey &&
            lhs.iv == rhs.iv &&
            lhs.macKey == rhs.macKey
    }
}
