// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: LocalStorage.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Signal_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var localIdentityPublic: Data {
    get {return _storage._localIdentityPublic ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._localIdentityPublic = newValue}
  }
  /// Returns true if `localIdentityPublic` has been explicitly set.
  var hasLocalIdentityPublic: Bool {return _storage._localIdentityPublic != nil}
  /// Clears the value of `localIdentityPublic`. Subsequent reads from it will return its default value.
  mutating func clearLocalIdentityPublic() {_storage._localIdentityPublic = nil}

  var remoteIdentityPublic: Data {
    get {return _storage._remoteIdentityPublic ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._remoteIdentityPublic = newValue}
  }
  /// Returns true if `remoteIdentityPublic` has been explicitly set.
  var hasRemoteIdentityPublic: Bool {return _storage._remoteIdentityPublic != nil}
  /// Clears the value of `remoteIdentityPublic`. Subsequent reads from it will return its default value.
  mutating func clearRemoteIdentityPublic() {_storage._remoteIdentityPublic = nil}

  var rootKey: Data {
    get {return _storage._rootKey ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._rootKey = newValue}
  }
  /// Returns true if `rootKey` has been explicitly set.
  var hasRootKey: Bool {return _storage._rootKey != nil}
  /// Clears the value of `rootKey`. Subsequent reads from it will return its default value.
  mutating func clearRootKey() {_storage._rootKey = nil}

  var previousCounter: UInt32 {
    get {return _storage._previousCounter ?? 0}
    set {_uniqueStorage()._previousCounter = newValue}
  }
  /// Returns true if `previousCounter` has been explicitly set.
  var hasPreviousCounter: Bool {return _storage._previousCounter != nil}
  /// Clears the value of `previousCounter`. Subsequent reads from it will return its default value.
  mutating func clearPreviousCounter() {_storage._previousCounter = nil}

  var senderChain: Signal_Session.Chain {
    get {return _storage._senderChain ?? Signal_Session.Chain()}
    set {_uniqueStorage()._senderChain = newValue}
  }
  /// Returns true if `senderChain` has been explicitly set.
  var hasSenderChain: Bool {return _storage._senderChain != nil}
  /// Clears the value of `senderChain`. Subsequent reads from it will return its default value.
  mutating func clearSenderChain() {_storage._senderChain = nil}

  var receiverChains: [Signal_Session.Chain] {
    get {return _storage._receiverChains}
    set {_uniqueStorage()._receiverChains = newValue}
  }

  var pendingPreKey: Signal_Session.PendingPreKey {
    get {return _storage._pendingPreKey ?? Signal_Session.PendingPreKey()}
    set {_uniqueStorage()._pendingPreKey = newValue}
  }
  /// Returns true if `pendingPreKey` has been explicitly set.
  var hasPendingPreKey: Bool {return _storage._pendingPreKey != nil}
  /// Clears the value of `pendingPreKey`. Subsequent reads from it will return its default value.
  mutating func clearPendingPreKey() {_storage._pendingPreKey = nil}

  var aliceBaseKey: Data {
    get {return _storage._aliceBaseKey ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._aliceBaseKey = newValue}
  }
  /// Returns true if `aliceBaseKey` has been explicitly set.
  var hasAliceBaseKey: Bool {return _storage._aliceBaseKey != nil}
  /// Clears the value of `aliceBaseKey`. Subsequent reads from it will return its default value.
  mutating func clearAliceBaseKey() {_storage._aliceBaseKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Chain {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var senderRatchetKey: Data {
      get {return _storage._senderRatchetKey ?? SwiftProtobuf.Internal.emptyData}
      set {_uniqueStorage()._senderRatchetKey = newValue}
    }
    /// Returns true if `senderRatchetKey` has been explicitly set.
    var hasSenderRatchetKey: Bool {return _storage._senderRatchetKey != nil}
    /// Clears the value of `senderRatchetKey`. Subsequent reads from it will return its default value.
    mutating func clearSenderRatchetKey() {_storage._senderRatchetKey = nil}

    var senderRatchetKeyPrivate: Data {
      get {return _storage._senderRatchetKeyPrivate ?? SwiftProtobuf.Internal.emptyData}
      set {_uniqueStorage()._senderRatchetKeyPrivate = newValue}
    }
    /// Returns true if `senderRatchetKeyPrivate` has been explicitly set.
    var hasSenderRatchetKeyPrivate: Bool {return _storage._senderRatchetKeyPrivate != nil}
    /// Clears the value of `senderRatchetKeyPrivate`. Subsequent reads from it will return its default value.
    mutating func clearSenderRatchetKeyPrivate() {_storage._senderRatchetKeyPrivate = nil}

    var chainKey: Signal_Session.Chain.ChainKey {
      get {return _storage._chainKey ?? Signal_Session.Chain.ChainKey()}
      set {_uniqueStorage()._chainKey = newValue}
    }
    /// Returns true if `chainKey` has been explicitly set.
    var hasChainKey: Bool {return _storage._chainKey != nil}
    /// Clears the value of `chainKey`. Subsequent reads from it will return its default value.
    mutating func clearChainKey() {_storage._chainKey = nil}

    var messageKeys: [Signal_Session.Chain.MessageKey] {
      get {return _storage._messageKeys}
      set {_uniqueStorage()._messageKeys = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ChainKey {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var index: UInt32 {
        get {return _index ?? 0}
        set {_index = newValue}
      }
      /// Returns true if `index` has been explicitly set.
      var hasIndex: Bool {return self._index != nil}
      /// Clears the value of `index`. Subsequent reads from it will return its default value.
      mutating func clearIndex() {self._index = nil}

      var key: Data {
        get {return _key ?? SwiftProtobuf.Internal.emptyData}
        set {_key = newValue}
      }
      /// Returns true if `key` has been explicitly set.
      var hasKey: Bool {return self._key != nil}
      /// Clears the value of `key`. Subsequent reads from it will return its default value.
      mutating func clearKey() {self._key = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _index: UInt32? = nil
      fileprivate var _key: Data? = nil
    }

    struct MessageKey {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var index: UInt32 {
        get {return _index ?? 0}
        set {_index = newValue}
      }
      /// Returns true if `index` has been explicitly set.
      var hasIndex: Bool {return self._index != nil}
      /// Clears the value of `index`. Subsequent reads from it will return its default value.
      mutating func clearIndex() {self._index = nil}

      var cipherKey: Data {
        get {return _cipherKey ?? SwiftProtobuf.Internal.emptyData}
        set {_cipherKey = newValue}
      }
      /// Returns true if `cipherKey` has been explicitly set.
      var hasCipherKey: Bool {return self._cipherKey != nil}
      /// Clears the value of `cipherKey`. Subsequent reads from it will return its default value.
      mutating func clearCipherKey() {self._cipherKey = nil}

      var macKey: Data {
        get {return _macKey ?? SwiftProtobuf.Internal.emptyData}
        set {_macKey = newValue}
      }
      /// Returns true if `macKey` has been explicitly set.
      var hasMacKey: Bool {return self._macKey != nil}
      /// Clears the value of `macKey`. Subsequent reads from it will return its default value.
      mutating func clearMacKey() {self._macKey = nil}

      var iv: Data {
        get {return _iv ?? SwiftProtobuf.Internal.emptyData}
        set {_iv = newValue}
      }
      /// Returns true if `iv` has been explicitly set.
      var hasIv: Bool {return self._iv != nil}
      /// Clears the value of `iv`. Subsequent reads from it will return its default value.
      mutating func clearIv() {self._iv = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _index: UInt32? = nil
      fileprivate var _cipherKey: Data? = nil
      fileprivate var _macKey: Data? = nil
      fileprivate var _iv: Data? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct PendingPreKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var preKeyID: UInt32 {
      get {return _preKeyID ?? 0}
      set {_preKeyID = newValue}
    }
    /// Returns true if `preKeyID` has been explicitly set.
    var hasPreKeyID: Bool {return self._preKeyID != nil}
    /// Clears the value of `preKeyID`. Subsequent reads from it will return its default value.
    mutating func clearPreKeyID() {self._preKeyID = nil}

    var signedPreKeyID: Int32 {
      get {return _signedPreKeyID ?? 0}
      set {_signedPreKeyID = newValue}
    }
    /// Returns true if `signedPreKeyID` has been explicitly set.
    var hasSignedPreKeyID: Bool {return self._signedPreKeyID != nil}
    /// Clears the value of `signedPreKeyID`. Subsequent reads from it will return its default value.
    mutating func clearSignedPreKeyID() {self._signedPreKeyID = nil}

    var baseKey: Data {
      get {return _baseKey ?? SwiftProtobuf.Internal.emptyData}
      set {_baseKey = newValue}
    }
    /// Returns true if `baseKey` has been explicitly set.
    var hasBaseKey: Bool {return self._baseKey != nil}
    /// Clears the value of `baseKey`. Subsequent reads from it will return its default value.
    mutating func clearBaseKey() {self._baseKey = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _preKeyID: UInt32? = nil
    fileprivate var _signedPreKeyID: Int32? = nil
    fileprivate var _baseKey: Data? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Signal_Record {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentSession: Signal_Session {
    get {return _storage._currentSession ?? Signal_Session()}
    set {_uniqueStorage()._currentSession = newValue}
  }
  /// Returns true if `currentSession` has been explicitly set.
  var hasCurrentSession: Bool {return _storage._currentSession != nil}
  /// Clears the value of `currentSession`. Subsequent reads from it will return its default value.
  mutating func clearCurrentSession() {_storage._currentSession = nil}

  var previousSessions: [Signal_Session] {
    get {return _storage._previousSessions}
    set {_uniqueStorage()._previousSessions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Signal_PreKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Signal_PreKey.PublicPart {
    get {return _storage._publicKey ?? Signal_PreKey.PublicPart()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {_storage._publicKey = nil}

  var privateKey: Data {
    get {return _storage._privateKey ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return _storage._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {_storage._privateKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PublicPart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var key: Data {
      get {return _key ?? SwiftProtobuf.Internal.emptyData}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt32? = nil
    fileprivate var _key: Data? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Signal_SignedPreKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Signal_SignedPreKey.PublicPart {
    get {return _storage._publicKey ?? Signal_SignedPreKey.PublicPart()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {_storage._publicKey = nil}

  var privateKey: Data {
    get {return _storage._privateKey ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return _storage._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {_storage._privateKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PublicPart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var key: Data {
      get {return _key ?? SwiftProtobuf.Internal.emptyData}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var signature: Data {
      get {return _signature ?? SwiftProtobuf.Internal.emptyData}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    mutating func clearSignature() {self._signature = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt32? = nil
    fileprivate var _key: Data? = nil
    fileprivate var _signature: Data? = nil
    fileprivate var _timestamp: UInt64? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Signal_KeyPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data {
    get {return _publicKey ?? SwiftProtobuf.Internal.emptyData}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var privateKey: Data {
    get {return _privateKey ?? SwiftProtobuf.Internal.emptyData}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {self._privateKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Data? = nil
  fileprivate var _privateKey: Data? = nil
}

struct Signal_SenderKeyState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var senderKeyID: UInt32 {
    get {return _storage._senderKeyID ?? 0}
    set {_uniqueStorage()._senderKeyID = newValue}
  }
  /// Returns true if `senderKeyID` has been explicitly set.
  var hasSenderKeyID: Bool {return _storage._senderKeyID != nil}
  /// Clears the value of `senderKeyID`. Subsequent reads from it will return its default value.
  mutating func clearSenderKeyID() {_storage._senderKeyID = nil}

  var senderChainKey: Signal_SenderKeyState.SenderChainKey {
    get {return _storage._senderChainKey ?? Signal_SenderKeyState.SenderChainKey()}
    set {_uniqueStorage()._senderChainKey = newValue}
  }
  /// Returns true if `senderChainKey` has been explicitly set.
  var hasSenderChainKey: Bool {return _storage._senderChainKey != nil}
  /// Clears the value of `senderChainKey`. Subsequent reads from it will return its default value.
  mutating func clearSenderChainKey() {_storage._senderChainKey = nil}

  var senderSigningKey: Signal_SenderKeyState.SenderSigningKey {
    get {return _storage._senderSigningKey ?? Signal_SenderKeyState.SenderSigningKey()}
    set {_uniqueStorage()._senderSigningKey = newValue}
  }
  /// Returns true if `senderSigningKey` has been explicitly set.
  var hasSenderSigningKey: Bool {return _storage._senderSigningKey != nil}
  /// Clears the value of `senderSigningKey`. Subsequent reads from it will return its default value.
  mutating func clearSenderSigningKey() {_storage._senderSigningKey = nil}

  var senderMessageKeys: [Signal_SenderKeyState.SenderMessageKey] {
    get {return _storage._senderMessageKeys}
    set {_uniqueStorage()._senderMessageKeys = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SenderChainKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var iteration: UInt32 {
      get {return _iteration ?? 0}
      set {_iteration = newValue}
    }
    /// Returns true if `iteration` has been explicitly set.
    var hasIteration: Bool {return self._iteration != nil}
    /// Clears the value of `iteration`. Subsequent reads from it will return its default value.
    mutating func clearIteration() {self._iteration = nil}

    var seed: Data {
      get {return _seed ?? SwiftProtobuf.Internal.emptyData}
      set {_seed = newValue}
    }
    /// Returns true if `seed` has been explicitly set.
    var hasSeed: Bool {return self._seed != nil}
    /// Clears the value of `seed`. Subsequent reads from it will return its default value.
    mutating func clearSeed() {self._seed = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _iteration: UInt32? = nil
    fileprivate var _seed: Data? = nil
  }

  struct SenderMessageKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var iteration: UInt32 {
      get {return _iteration ?? 0}
      set {_iteration = newValue}
    }
    /// Returns true if `iteration` has been explicitly set.
    var hasIteration: Bool {return self._iteration != nil}
    /// Clears the value of `iteration`. Subsequent reads from it will return its default value.
    mutating func clearIteration() {self._iteration = nil}

    var seed: Data {
      get {return _seed ?? SwiftProtobuf.Internal.emptyData}
      set {_seed = newValue}
    }
    /// Returns true if `seed` has been explicitly set.
    var hasSeed: Bool {return self._seed != nil}
    /// Clears the value of `seed`. Subsequent reads from it will return its default value.
    mutating func clearSeed() {self._seed = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _iteration: UInt32? = nil
    fileprivate var _seed: Data? = nil
  }

  struct SenderSigningKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `public`: Data {
      get {return _public ?? SwiftProtobuf.Internal.emptyData}
      set {_public = newValue}
    }
    /// Returns true if ``public`` has been explicitly set.
    var hasPublic: Bool {return self._public != nil}
    /// Clears the value of ``public``. Subsequent reads from it will return its default value.
    mutating func clearPublic() {self._public = nil}

    var `private`: Data {
      get {return _private ?? SwiftProtobuf.Internal.emptyData}
      set {_private = newValue}
    }
    /// Returns true if ``private`` has been explicitly set.
    var hasPrivate: Bool {return self._private != nil}
    /// Clears the value of ``private``. Subsequent reads from it will return its default value.
    mutating func clearPrivate() {self._private = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _public: Data? = nil
    fileprivate var _private: Data? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Signal_SenderKeyRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var senderKeyStates: [Signal_SenderKeyState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Signal"

extension Signal_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Session"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localIdentityPublic"),
    2: .same(proto: "remoteIdentityPublic"),
    3: .same(proto: "rootKey"),
    4: .same(proto: "previousCounter"),
    5: .same(proto: "senderChain"),
    6: .same(proto: "receiverChains"),
    7: .same(proto: "pendingPreKey"),
    8: .same(proto: "aliceBaseKey"),
  ]

  fileprivate class _StorageClass {
    var _localIdentityPublic: Data? = nil
    var _remoteIdentityPublic: Data? = nil
    var _rootKey: Data? = nil
    var _previousCounter: UInt32? = nil
    var _senderChain: Signal_Session.Chain? = nil
    var _receiverChains: [Signal_Session.Chain] = []
    var _pendingPreKey: Signal_Session.PendingPreKey? = nil
    var _aliceBaseKey: Data? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localIdentityPublic = source._localIdentityPublic
      _remoteIdentityPublic = source._remoteIdentityPublic
      _rootKey = source._rootKey
      _previousCounter = source._previousCounter
      _senderChain = source._senderChain
      _receiverChains = source._receiverChains
      _pendingPreKey = source._pendingPreKey
      _aliceBaseKey = source._aliceBaseKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._localIdentityPublic)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._remoteIdentityPublic)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._rootKey)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._previousCounter)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._senderChain)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._receiverChains)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._pendingPreKey)
        case 8: try decoder.decodeSingularBytesField(value: &_storage._aliceBaseKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._localIdentityPublic {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      }
      if let v = _storage._remoteIdentityPublic {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      }
      if let v = _storage._rootKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      }
      if let v = _storage._previousCounter {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._senderChain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._receiverChains.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._receiverChains, fieldNumber: 6)
      }
      if let v = _storage._pendingPreKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._aliceBaseKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_Session) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._localIdentityPublic != other_storage._localIdentityPublic {return false}
        if _storage._remoteIdentityPublic != other_storage._remoteIdentityPublic {return false}
        if _storage._rootKey != other_storage._rootKey {return false}
        if _storage._previousCounter != other_storage._previousCounter {return false}
        if _storage._senderChain != other_storage._senderChain {return false}
        if _storage._receiverChains != other_storage._receiverChains {return false}
        if _storage._pendingPreKey != other_storage._pendingPreKey {return false}
        if _storage._aliceBaseKey != other_storage._aliceBaseKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_Session.Chain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_Session.protoMessageName + ".Chain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderRatchetKey"),
    2: .same(proto: "senderRatchetKeyPrivate"),
    3: .same(proto: "chainKey"),
    4: .same(proto: "messageKeys"),
  ]

  fileprivate class _StorageClass {
    var _senderRatchetKey: Data? = nil
    var _senderRatchetKeyPrivate: Data? = nil
    var _chainKey: Signal_Session.Chain.ChainKey? = nil
    var _messageKeys: [Signal_Session.Chain.MessageKey] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _senderRatchetKey = source._senderRatchetKey
      _senderRatchetKeyPrivate = source._senderRatchetKeyPrivate
      _chainKey = source._chainKey
      _messageKeys = source._messageKeys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._senderRatchetKey)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._senderRatchetKeyPrivate)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._chainKey)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._messageKeys)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._senderRatchetKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      }
      if let v = _storage._senderRatchetKeyPrivate {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      }
      if let v = _storage._chainKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._messageKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messageKeys, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_Session.Chain) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._senderRatchetKey != other_storage._senderRatchetKey {return false}
        if _storage._senderRatchetKeyPrivate != other_storage._senderRatchetKeyPrivate {return false}
        if _storage._chainKey != other_storage._chainKey {return false}
        if _storage._messageKeys != other_storage._messageKeys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_Session.Chain.ChainKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_Session.Chain.protoMessageName + ".ChainKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._index)
      case 2: try decoder.decodeSingularBytesField(value: &self._key)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_Session.Chain.ChainKey) -> Bool {
    if self._index != other._index {return false}
    if self._key != other._key {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_Session.Chain.MessageKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_Session.Chain.protoMessageName + ".MessageKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "cipherKey"),
    3: .same(proto: "macKey"),
    4: .same(proto: "iv"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._index)
      case 2: try decoder.decodeSingularBytesField(value: &self._cipherKey)
      case 3: try decoder.decodeSingularBytesField(value: &self._macKey)
      case 4: try decoder.decodeSingularBytesField(value: &self._iv)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._cipherKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._macKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._iv {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_Session.Chain.MessageKey) -> Bool {
    if self._index != other._index {return false}
    if self._cipherKey != other._cipherKey {return false}
    if self._macKey != other._macKey {return false}
    if self._iv != other._iv {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_Session.PendingPreKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_Session.protoMessageName + ".PendingPreKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preKeyId"),
    2: .same(proto: "signedPreKeyId"),
    3: .same(proto: "baseKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._preKeyID)
      case 2: try decoder.decodeSingularInt32Field(value: &self._signedPreKeyID)
      case 3: try decoder.decodeSingularBytesField(value: &self._baseKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._preKeyID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._signedPreKeyID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._baseKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_Session.PendingPreKey) -> Bool {
    if self._preKeyID != other._preKeyID {return false}
    if self._signedPreKeyID != other._signedPreKeyID {return false}
    if self._baseKey != other._baseKey {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currentSession"),
    2: .same(proto: "previousSessions"),
  ]

  fileprivate class _StorageClass {
    var _currentSession: Signal_Session? = nil
    var _previousSessions: [Signal_Session] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _currentSession = source._currentSession
      _previousSessions = source._previousSessions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._currentSession)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._previousSessions)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._currentSession {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._previousSessions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._previousSessions, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_Record) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._currentSession != other_storage._currentSession {return false}
        if _storage._previousSessions != other_storage._previousSessions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_PreKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "privateKey"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: Signal_PreKey.PublicPart? = nil
    var _privateKey: Data? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
      _privateKey = source._privateKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._privateKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._privateKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_PreKey) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._publicKey != other_storage._publicKey {return false}
        if _storage._privateKey != other_storage._privateKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_PreKey.PublicPart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_PreKey.protoMessageName + ".PublicPart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._id)
      case 2: try decoder.decodeSingularBytesField(value: &self._key)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_PreKey.PublicPart) -> Bool {
    if self._id != other._id {return false}
    if self._key != other._key {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_SignedPreKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedPreKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "privateKey"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: Signal_SignedPreKey.PublicPart? = nil
    var _privateKey: Data? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
      _privateKey = source._privateKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._privateKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._privateKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_SignedPreKey) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._publicKey != other_storage._publicKey {return false}
        if _storage._privateKey != other_storage._privateKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_SignedPreKey.PublicPart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SignedPreKey.protoMessageName + ".PublicPart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
    3: .same(proto: "signature"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._id)
      case 2: try decoder.decodeSingularBytesField(value: &self._key)
      case 3: try decoder.decodeSingularBytesField(value: &self._signature)
      case 4: try decoder.decodeSingularFixed64Field(value: &self._timestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._signature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._timestamp {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_SignedPreKey.PublicPart) -> Bool {
    if self._id != other._id {return false}
    if self._key != other._key {return false}
    if self._signature != other._signature {return false}
    if self._timestamp != other._timestamp {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_KeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "privateKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._publicKey)
      case 2: try decoder.decodeSingularBytesField(value: &self._privateKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._privateKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_KeyPair) -> Bool {
    if self._publicKey != other._publicKey {return false}
    if self._privateKey != other._privateKey {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SenderKeyState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderKeyId"),
    2: .same(proto: "senderChainKey"),
    3: .same(proto: "senderSigningKey"),
    4: .same(proto: "senderMessageKeys"),
  ]

  fileprivate class _StorageClass {
    var _senderKeyID: UInt32? = nil
    var _senderChainKey: Signal_SenderKeyState.SenderChainKey? = nil
    var _senderSigningKey: Signal_SenderKeyState.SenderSigningKey? = nil
    var _senderMessageKeys: [Signal_SenderKeyState.SenderMessageKey] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _senderKeyID = source._senderKeyID
      _senderChainKey = source._senderChainKey
      _senderSigningKey = source._senderSigningKey
      _senderMessageKeys = source._senderMessageKeys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._senderKeyID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._senderChainKey)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._senderSigningKey)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._senderMessageKeys)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._senderKeyID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._senderChainKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._senderSigningKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._senderMessageKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._senderMessageKeys, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_SenderKeyState) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._senderKeyID != other_storage._senderKeyID {return false}
        if _storage._senderChainKey != other_storage._senderChainKey {return false}
        if _storage._senderSigningKey != other_storage._senderSigningKey {return false}
        if _storage._senderMessageKeys != other_storage._senderMessageKeys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyState.SenderChainKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SenderKeyState.protoMessageName + ".SenderChainKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "iteration"),
    2: .same(proto: "seed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._iteration)
      case 2: try decoder.decodeSingularBytesField(value: &self._seed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._iteration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._seed {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_SenderKeyState.SenderChainKey) -> Bool {
    if self._iteration != other._iteration {return false}
    if self._seed != other._seed {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyState.SenderMessageKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SenderKeyState.protoMessageName + ".SenderMessageKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "iteration"),
    2: .same(proto: "seed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._iteration)
      case 2: try decoder.decodeSingularBytesField(value: &self._seed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._iteration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._seed {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_SenderKeyState.SenderMessageKey) -> Bool {
    if self._iteration != other._iteration {return false}
    if self._seed != other._seed {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyState.SenderSigningKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SenderKeyState.protoMessageName + ".SenderSigningKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "public"),
    2: .same(proto: "private"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._public)
      case 2: try decoder.decodeSingularBytesField(value: &self._private)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._public {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._private {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_SenderKeyState.SenderSigningKey) -> Bool {
    if self._public != other._public {return false}
    if self._private != other._private {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SenderKeyRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderKeyStates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.senderKeyStates)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.senderKeyStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.senderKeyStates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Signal_SenderKeyRecord) -> Bool {
    if self.senderKeyStates != other.senderKeyStates {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
